<8월 24일>
리액트? 
props, state 제어해야함
= js/ts (object, arry, string...)
jsx element와 바인딩

immer 없을때 : 직접 새로운 객체 생성
사용할때 : 변경될 객체(새로운 객체)를 immer가 생성함, 해당객체를 조작함(push, splice, unshift...)

state 변경
-> 원시값(넘버, 스트링, 불린)
-> 값이 변경되어야함

-> 객체(오브젝트, 어레이)
-> 참조가 바뀌어야함
-> 새로운 객체를 생성해야함

immer : 불변성 관리

filter = 삭제할 하이템을 제외하고 새로운 배열 생성
splice = 삭제할 아이템의 인덱스 해당 요소 직접 삭제

----------------------------------------------------------------------------------------------


<8월 25일>
props down : state 제어함수를 자식컴포넌트에 속성으로 내림
event-up : 자식컨포넌트에서 이벤트가 발생하면 부모로부터 받은 함수를 실행
useref : 뭔가를 참조하는 변수를 생성한다 (오후 4시 43분)

----------------------------------------------------------------------------------------------

<8월 30일>

Flux : 클라이언트 데이터 관리 아키텍쳐, 단방향 데이터 흐름
-> view 에서 store 조회 -> view에서 Action객체를 Dispatcher로 넘김-> Dispatcher가 Store 변경

Redux : Flux 패턴을 라이브러리(js/ts)만들어놓은것
	-> ActionCreator : 액션객체를 생성하는 함수
	-> Action : 액션타입(명령), 페이로드(데이터, 유사 매개변수) 구조의 객체
	-> Dispatcher : 액션타입과 페이로드를 받아서 리듀서를 실행
	-> Reducer : 기존 state와 액션의 페이로드로 state변경
		(각 state 별로 처리할 reducer목록)
React Redux : React에서 Redux를 쓸 수 있게 만들어 놓은 것

1. Action creator(Action -type : 액션 종류 ,-payload : 실제 데이터 )
action 스테이트 변경 정보, payload : 실제 데이터
2. dispatcher(디스패쳐 내에 Reducer가 존재) 실제로 스테이트 변경하는 건 리듀서!
2-1 리듀서로 새로들어온 액션이 들어옴
2-2 기존 스테이트가 들어옴
위 2-1,2-2를 통해 스테이트를 변경
3. view : 변경된 스테이트를 가져감(이 행위를 select라고 함)

글로벌스테이트는 전역상태 저장소
글로벌스테이트의 스테이트들은 다른 컴포넌트와 state가 공유됨

tsx : react component
ts : type Script
Redux-Store 전체 저장소(Global store)
Slice : redux store(리덕스 저장소)에 하나의 state를 slice라고 함(오전 11시 10분)
slice 리듀서에서 생성 후 전체저장소에서 생성한 리듀서 등록->
전체저장소에서 슬라이스-리듀서 가져오기(useSelect사용)->useDispatch 사용해서 액션을 디스패칭함

contact linlineEdit (11시 30분) tr 내 인풋박스 3개를 쿼리셀렉터올로 제어해야함

---------------------------------------------------------------------------------------------
<8월 31일 - cmd 명령어, 서버 만들기>
-------------------------------
<9월 1일 photo 생성시작(create)>
---------------------------------------------------------------------------------------------
<9월 4일 비쥬얼패러다임>
---------------------------------------------------------------------------------------------
<9월 6일 자바 시작>
---------------------------------------------------------------------------------------------
<9월 7일 자바-메소드>
오버로딩 : 메소드 이름은 동일하고 매개변수의 타입, 개수, 순서가 달라야함

static 메소드 : 객체 생성없이 호출해서 사용할 수 있는 메소드
static 변수에는 this 사용 불가 (this : 생성된 객체)

final : (자바스크립트의 const 상수와 비슷) 수정불가함 -> final을 사용하여 고정값만 사용함
// static 변수를 사용한다는 것은 공용적인 사용임
// 수정 못하게 하는게 일반적

비쥬얼패러다임 설정
uml (unified modeling language) 통합적인 설계 언어, 국제 표준 지정, 설계 방법
forward engineering : 설계 -> 코드
reverse engineering : 코드 -> 설계

클래스 - 구조
객체, 인스턴스 - 구조로 만들어낸 것

// class diagram
1. 클래스의 캡슐화(encapsulation)를 표현
캡슐화 : 필드, 메소드로 클래스를 표현(속성과 기능으로 구조를 만듦)

2. 클래스간의 관계(relationship)를 표현
dependency (의존관계) : 클래스 변동사항이 다른 클래스에 영향을 미침
-> 클래스를 변경하면 클래스를 가져다 쓰는 쪽에 영향을 미침
-> 자바(코드)
	1. 메소드에서 다른 클래스 객체를 생성해서 사용함
	2. 메소드의 매개변수로 다른 클래스 객체를 받음
   - 의존성 주입 (Dependency Injection) : 의존 객체를 외부에서 생성해서 메소드 매개변수로 넣어줌 
 - uml 표기법은
<<instantiate>>, <<use>> : stereo type -> 기본 UML 표기법 외에 추가적인 내용을 표기하는 방법
-association (연관관계) : 두개의 클래스가 관계가 있음
자바(코드) : 클래스의 필드로 다른 클래스의 객체를 참조
-uml : 일반 줄, 탐색방향에 따라서 화살표처리
-aggregation(집합관계) : 연관관계이면서 부분-전체(포함) 관계
자바(코드) : 연관관계와 동일하지만 논리적인 포함관계
-uml : 다이아몬드 줄, 집합관계

// sequence diagram : 시퀀스, 순서
-> 객체 간 메시지(데이터, 매개변수, 값, 객체)를 주고받는 흐름을 표현
- actor : 처리 주체 -> 사용자, 개발자, 관리자.. 등
- lifeline : (상호작용에 참여하는) 객체를 표현
  표기법 > 객체명 : 타입명
- Message : Actor 또는 lifeline 간 주고받는 내용
- Create Message : 객체를 생성
- Activation : 객체가 처리중에 활성화된 시간을 표현
---------------------------------------------------------------------------------------------
<9월 8일 접근제한자>
default : 외부패키지에서 사용이 안됨
protected : 외부패키지에서 사용불가지만 이 클래스를 상속받아서 extends 사용하면 사용 가능
public : 모든 곳에서 사용 가능
private : 외부에서 접근 불가 (기본적으로 자바에서 필드는 private으로 설정되어있음)
	-> 이 필드에 접근하기 위해 getter/setter 사용
	// public 필드타입 get필드명
	// public void set필드명(필드타입 변수명){
	// this.필드명 = 변수명;
	// }

클래스다이어그램 <<Property >> : get/set 가능

전체 프로그램에서 어떤 클래스들은 객체 유일하게 1개만 존재할 필요가 있음
이런 경우의 클래스는 싱글턴 패턴을 적용
싱글턴 : 객체로 찍어내는 클래스가 아님, 메소드를 기능적인 관점에서 실행하는 클래스
싱글턴 클래스로 만들어 외부에서 객체 생성을 못하게 함
(객체 생성 순서)1. 기본 생성자를 외부에서 접근 못하게 함
	2. private static 필드로 객체를 생성함 <- 프로그램이 실행될 때 변수 초기화가 일어남
	3. 외부에서 private static 으로 생성한 객체를 접근할 수 있게 함

일반필드, 일반메소드 -> 객체를 생성할 때 메모리 공간 초기화가 일어남

static 필드/메소드 -> 프로그램이 실행될 때 메소드 공간(클래스 공간)에 초기화가 일어남

Map 여러가지 형태의 Map 가능한 타입(Interface)

대입하는 자료구조에 따라서 같은 메소드를 호출하더라도 내부적인 처리방식이 다름
키/값으로 이뤄진 객체
---------------------------------------------------------------------------------------------
<9월 9일 hashcode> 
직접 생성한 class는 hashcode하고 equals 기본적으로 메모리 주소만 비교

---------------------------------------------------------------------------------------------
<9월 10일>
interface : 클래스의 특수형태, 구현체는 없고 껍데기만 있음
=> 추상메소드 선언, 메소드 본체(정의 부분)없음, 객체를 생성할 수 없음
mock : 위 상황의 경우 객체 생성이 불가능, 이를 방지하기 위해 가짜 데이터
인터페이스 규격에 맞게 목업클래스 생성, 
구현목업클래스명 implements 구현클래스명 (add on 어쩌구 누르면 자동필드 생성됨)

대부분이 추상메소드 : 인터페이스 사용 (일부는 구현된게 있어 디폹 메서드)
대부분이 구현메소드 : 추상클래스 사용 (일부는 추상메소드)

상속과 인터페이스
상속 : 있는 거를 가져다 씀, 추가적인가 추가하기, 재정의(extends)
인터페이스 : 설계대로 만들어 구현, 필요할 때 실 데이터로 갈아껴(implements)
---------------------------------------------------------------------------------------------
<9월 13일>
lombok 다운/설명

// 롬복 플러그인이 java코드를 컴파일할때 롬복 어노테이션이 있는 클래스/인터페이스, 필드, 메소드를 탐색
@Data :  getter, setter, equals/hascode, tostring 메소드를 컴파일되는 class파일에 추가해줌
@RestController : controller 인데, 응답으로 데이터 객체만 처리
controller? : Http 요청에 대한 응답을 처리할 수 있는 클래스
@RequestMapping(value="/",method=RequestMethod.GET) : 
@SpringBootApplication
@SpringBootConfiguration : 객체 생성/주입 관리자를 만듦( IOC 컨테이너)
@EnableAutoConfiguration : 의존성에 따라서 환경 자동 구성 -> 톰켓 웹서버 실행, 디패서블릿 객체 생성
@ComponentScan : 컴포넌트들을 검색하여 싱글턴 객체 생성
@Autowired : 톰캣
서블릿 : 응답 결과도 뭐도 일단 최강중간자...?

1. 브라우저에서 요청이 들어옴
http method : GET
http Request URL : /hello

2. 서블릿(java class)에서 요청 정보를 확인 GET/hello
-> 해당하는 controller 클래스의 메소드를 실행하고 결과를 반환

POST /todos {"memo":"..."}
GET /todos

// REST API
1. 행위와 자원의 URL로 자원에 접근하는 방법을 표현
    -> 자원(리소스) : *객체, 메소드, *테이블, 프로시저...
 : /todos <- todos 객체에 접근하겠다. (todo목록에 접근하겠다)
    -> 행위(메소드) : HTTP Method (GET, POST, PUT, PATCH, DELETE)
 : 자원에 대해서 어떤 방식으로 접근하겠냐

GET -> 리소스를 가져오겠다
POST -> 리소스에 추가하겠다.
PUT -> 리소스를 수정하겠다.
PATCH -> 리소스의 일부분을 수정하겠다.
DELETE -> 리소스의 일부분을 삭제하겠다.

예)
POST /todos : todo 목록에 todo 1건을 추가하겠다.
GET /todos : todo 목록을 가져오겠다.

2. Client - Server 구조이다
-------------------------------------------------
HTTP 프로토콜은 Request(요청) - Response(응답)
- 요청하는 쪽이 Client, 응답하는 쪽이 Server
-------------------------------------------------
HTTP Request 해부
-> 요청하는 쪽의 정보구조를 파악
-HTTP Request LIne 
 - HTTP 메소드, 요청url, version
  -> POST http://localhost:8080/todos HTTP 1.1
-HTTP Request Header
 -Host : 응답받을 서버의 주소
 -User-Agent : 요청보내는 클라이언트의 정보(OS, 브라우저)
 -Accept : 응답받을 데이터의 형식(파일에 대한 MIME Type */*은 모든타입)
-HTTP Request Body (옵션)
 - 보내는 데이터를 넣는 부분
 - Json(Javascript object Notation) : js객체 표기법
  (예) {"memo": "테스트메모", "key":"value"}
 - application/x-www-form-urlencoded
  (예) memo=테스트메모&key=value
 - Spring Controller에서 @RequestBody 어노테이션에 의해서 제이선 -> 객체 자동 변환
   Req. JSON -> Dispatcher Servlet -> HTTPMessageConverter -> Object(Todo)
   {"memo": "테스트메모"}                                             =>Todo(memo="테스트메모")
   문자열 					   -> 객체


HTTP Response 해부
-> 응답을 주는 쪽의 정보구조를 파악
 - HTTP Response Line
  - Status Code : 처리된 결과에 따른 코드값
	2XX : 정상처리
	3XX : 컨텐츠 이동
	4XX : 클라이언트 오류
	5XX : 서버 오류
 - HTTP Response Header
   - Content type : 응답을 보내는 데이터의 형식 
     (예 - application/json)
 - HTTP Response Body
     (예 -  {"id": 1,
        "memo": "test메모입니다.",
        "createdTime": 1631541537534
    })
 - Spring Controller에서 @Response Body 어노테이션에 의해 객체 -> 제이선 자동 변환
  Todo(id=1, memo="테스트메모"...) =>  { "id": 1, "memo": "테스트메모"...}

----------------------------------------------------------------------------------------------

<9월 14일>
web server
- html, css, js, img, vid => 정적컨텐츠 (서버에서 렌더링/계산 등 처리하지 않음)

was (web appliation server) - jsp, java => 동적컨텐츠 (서버에서 처리)

톰캣은 웹서버, 와스 다 가능

put/get : 동시 처리 시, 다른 스레드가 키로 접근 못하도록 lock

-----------------------------
TDD(Test Driven Developement)개발 스타일
사용자 needs(user story) -> 요구사항(requirement, backlog) -> 설계design, architecture ->code stub -> testcase(유즈케이스)(코드)->구현->테스트케이스 통과
		=>액터(수행자)
		이벤트 흐름(처리절차)
		사전조건, 예상결과

테스트
애플리케이션/시스템의 품질을 측정할 수 있는 유일한 방법
---------------------------
unit test
-자바 관점으로 봤을 때 클래스의 메소드들을 테스트하는 것

intergration test
-백엔드 관점으로 봤을 때는 api를 테스트하는 것
-서버를 띄우고, 네트워크로 데이터를 보내고 처리 결과까지 확인

빌드점그래들->자코코 넣은 다음 그래들->리프레시그래들프로젝트
윈도우 쇼뷰 other -> gradle tasks 추가

---------------------------------------------------------------------------------------------
<10월 5일>
case)
-데이터 갱신주기 1시간/1일 데이터 추가(수정/삭제)
-데이터 조회는 지속적으로 일어남

solution)
-데이터를 좀 더 빠른 공간에 저장 - 캐시(임시 저장소에 저장)
-데이터 갱신주기에 캐시를 삭제

캐시 데이터베이스를 사용
- 일반 관계형 데이터베이스보다 좀 더 빠른
- in -memory 데이터 베이스
- 좀 더 조회 성능에 최적화된 데이터베이스

- in -memory 데이터베이스
- 현재데이터
- 최근 데이터
- redis : key-value 데이터 구조를 가짐, 응답 성능 최적화 시 사용

document 데이터베이스
-이력 데이터
-mongo-db
---------------------------------------------------------------------------------------------
<10월 8일>

4계층 (전송계층, transport layer)
-TCP : 접속을 3번의 handshake로 접속을 맺음. 에러 보정
 -> 데이터 통신, 파일 통신
-UDP : 상대방에게 그냥 보냄
-> 실시간 스트리밍 (실시간 흐름에 따라서 데이터가 계속 변함)
-> (VoIP : voice over internet protocol 인터넷 전화) 
-> RTMP, HLS

7계층(응용계층, application layer)
-HTTP, WS, FTP, SSH, SCP

